# -*- coding: utf-8 -*-
"""linear binary insertion heap.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G6DpUf5bzX8glk89tyoDwWfnwv3_6KwQ
"""

import random
import time
import matplotlib.pyplot as plt

# Linear Search Implementation
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Element found
    return -1  # Element not found

# Function to generate random lists of size n
def generate_random_list(n):
    return [random.randint(1, 100000) for _ in range(n)]

# Function to test the linear search and measure time
def test_linear_search(n, target):
    # Generate a random list of size n
    arr = generate_random_list(n)

    # Measure the time taken for linear search
    start_time = time.time()
    linear_search(arr, target)
    end_time = time.time()

    # Return the time taken in seconds
    return end_time - start_time

# Experiment for different values of n
n_values = [100, 500, 1000, 5000, 10000, 20000, 50000]
times_taken = []

# Let's choose a random target from the range of numbers we generated
target = random.randint(1, 100000)

for n in n_values:
    time_taken = test_linear_search(n, target)
    times_taken.append(time_taken)

# Plotting the graph
plt.plot(n_values, times_taken, marker='o', linestyle='-', color='b')
plt.title('Time Taken vs List Size (Linear Search)')
plt.xlabel('Number of Elements (n)')
plt.ylabel('Time Taken (seconds)')
plt.grid(True)
plt.show()

import random
import time
import matplotlib.pyplot as plt

# Recursive Binary Search Implementation
def binary_search(arr, target, low, high):
    if high >= low:
        mid = (low + high) // 2
        # If the element is present at the mid
        if arr[mid] == target:
            return mid
        # If element is smaller than mid, it can only be in the left subarray
        elif arr[mid] > target:
            return binary_search(arr, target, low, mid - 1)
        # Otherwise, the element can only be in the right subarray
        else:
            return binary_search(arr, target, mid + 1, high)
    else:
        # Element is not present in the array
        return -1

# Function to generate random lists of size n
def generate_random_list(n):
    return sorted([random.randint(1, 100000) for _ in range(n)])

# Function to test the binary search and measure time
def test_binary_search(n, target):
    # Generate a sorted random list of size n
    arr = generate_random_list(n)

    # Measure the time taken for binary search
    start_time = time.time()
    binary_search(arr, target, 0, n - 1)
    end_time = time.time()

    # Return the time taken in seconds
    return end_time - start_time

# Experiment for different values of n
n_values = [100, 500, 1000, 5000, 10000, 20000, 50000]
times_taken = []

# Let's choose a random target from the range of numbers we generated
target = random.randint(1, 100000)

for n in n_values:
    time_taken = test_binary_search(n, target)
    times_taken.append(time_taken)

# Plotting the graph
plt.plot(n_values, times_taken, marker='o', linestyle='-', color='r')
plt.title('Time Taken vs List Size (Recursive Binary Search)')
plt.xlabel('Number of Elements (n)')
plt.ylabel('Time Taken (seconds)')
plt.grid(True)
plt.show()

import random
import time
import matplotlib.pyplot as plt

# Insertion Sort Implementation
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Heap Sort Implementation
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left

    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    # Build a max heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # Extract elements from the heap one by one
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # Swap
        heapify(arr, i, 0)

    return arr

# Function to generate random lists of size n
def generate_random_list(n):
    return [random.randint(1, 100000) for _ in range(n)]

# Function to test sorting algorithms and measure time
def test_sorting_algorithm(n, sorting_func):
    arr = generate_random_list(n)

    # Measure the time taken to sort the list
    start_time = time.time()
    sorting_func(arr)
    end_time = time.time()

    # Return the time taken in seconds
    return end_time - start_time

# Experiment for different values of n
n_values = [100, 500, 1000, 5000, 10000, 20000, 50000]
times_insertion_sort = []
times_heap_sort = []

for n in n_values:
    time_insertion_sort = test_sorting_algorithm(n, insertion_sort)
    times_insertion_sort.append(time_insertion_sort)

    time_heap_sort = test_sorting_algorithm(n, heap_sort)
    times_heap_sort.append(time_heap_sort)

# Plotting the graph
plt.plot(n_values, times_insertion_sort, marker='o', linestyle='-', color='r', label='Insertion Sort')
plt.plot(n_values, times_heap_sort, marker='o', linestyle='-', color='b', label='Heap Sort')
plt.title('Time Taken vs List Size (Sorting Algorithms)')
plt.xlabel('Number of Elements (n)')
plt.ylabel('Time Taken (seconds)')
plt.legend()
plt.grid(True)
plt.show()